<!--
 * @Date: 2025-03-03
 * @LastEditors: GoKo-Son626
 * @LastEditTime: 2025-03-04
 * @FilePath: /Day-Do/25-3-3.md
 * @Description: 
-->
### 3.1. linux->commit
**(06aac7187ecc8407dda5b67eeb109f84b43cf81a)**

**作用是在 RISC-V KVM（Kernel-based Virtual Machine）中为 Guest（虚拟机）增加对 Smnpm 和 Ssnpm 这两个扩展的支持。**

- Smnpm（Supervisor-mode **Non-maskable Pointer Masking（不可绕过指针屏蔽）**）-> **Hypervisor层(管理程序层)的指针掩码**
  - 这是一个**在 Supervisor 模式（S-mode）下提供指针屏蔽（Pointer Masking）功能的扩展**。
  - 这个扩展的目标是增强安全性，防止 S-mode 下的恶意代码泄露敏感指针信息。
  - 用于 Hypervisor 层（管理虚拟机的 OS），Hypervisor 需要开启它，Guest OS 才能用 Ssnpm。
  - 作用是给 Hypervisor 提供指针掩码，防止 Guest 越权访问 Host 资源。
  - 如果 Hypervisor 没有 Smnpm，那么 Guest 的 Ssnpm 也无法启用
- Ssnpm（Supervisor Sub-mode Non-maskable Pointer Masking）
  - **Ssnpm 是 Smnpm 的子集，用于 VS-mode（虚拟机的 S-mode）。**
  - 关键点：
    - henvcfg（Hypervisor Environment Configuration Register）是 RISC-V H 扩展（Hypervisor 扩展）中的一个寄存器，主要用于控制 Guest OS（虚拟机） 运行时的权限和行为。
    - henvcfg.PMM（Hypervisor 环境配置寄存器中的 Pointer Masking Mode 位）是 VS-mode 控制指针屏蔽的关键位。->  **用于控制 Guest OS 指针掩码机制**
    - Ssnpm 依赖于 henvcfg.PMM，而不是 Smnpm。
    - 用于 Guest 层（虚拟机里的 OS），控制 henvcfg.PMM 这个寄存器。
    - 作用是 限制 Guest OS 访问某些内存地址，防止信息泄露。
    - 只影响 Guest OS 自己的进程，不会影响 Hypervisor。
- **结论**
  - 主机（Host） 需要支持 Ssnpm，才能让 Guest（虚拟机）使用 Smnpm。
  - 当前 KVM 还没有实现 SBI（Supervisor Binary Interface）中的“Firmware Features”扩展，所以 Smnpm 目前对 Guest 无实际影响。
  - Ssnpm 需要通过 senvcfg CSR（Control Status Register，控制状态寄存器）配置，而 KVM 没有拦截该 CSR，因此 Guest 仍然可以看到 Ssnpm。

- **Hypervisor 层（虚拟机管理程序/**管理程序层）：
  - 直接运行在 物理硬件 上。（计算机硬件和虚拟机之间）
  - 负责管理 多个 Guest OS（虚拟机）。
  - 控制 CPU、内存、I/O 访问，分配资源给 Guest OS。
  - 相当于“宿主机”或者“虚拟化管理器”，比如 QEMU/KVM、VMware ESXi、Xen 等。
- **Guest 层（客户机层）：**
  - 运行在 虚拟机里，由 Hypervisor 提供 CPU、内存等资源。
  - 相当于“虚拟机里的操作系统”，比如运行 Linux、Windows、FreeBSD 等系统的虚拟机。

- **环境配置寄存器**
在 RISC-V 架构中，不同模式（用户态、监督态、Hypervisor 等）都有自己的环境配置寄存器，主要用于管理特定运行模式下的行为。

  - 主要的环境配置寄存器
  
| 寄存器  | 作用                         | 说明                                 |
| ------- | ---------------------------- | ------------------------------------ |
| senvcfg | Supervisor（S 模式）环境配置 | 监督模式 OS 用于管理进程             |
| henvcfg | Hypervisor（H 模式）环境配置 | Hypervisor 用于管理 Guest 虚拟机     |
| menvcfg | Machine（M 模式）环境配置    | 机器模式（最高权限）用于管理整个 CPU |

其中，henvcfg.PMM 主要用于 Hypervisor 管理 Guest 的指针掩码

- **SBI** 
  - SBI（Supervisor Binary Interface，监督二进制接口）是 RISC-V 的一个标准化接口，用于在 Supervisor OS（例如 Linux） 和 固件（例如 OpenSBI） 之间进行通信。
  - 提供 Hypervisor 或 固件 的一些低级功能，Guest OS 可以调用这些功能，而不直接访问硬件

- **SBI Firmware Features 扩展**
  - Firmware Features 扩展是 SBI 的一个功能，它提供了 查询和管理固件功能 的能力，比如：

  - 查看 Hypervisor 是否支持某个 RISC-V 扩展（如 Smnpm、Ssnpm）。
  - 获取系统可用的 CPU 资源信息。
  - 控制 CPU 进入低功耗模式。
  - 作用：
    - Hypervisor 通过 SBI 查询当前硬件支持哪些虚拟化扩展。
    - Guest OS 通过 SBI 了解宿主机的功能，并进行优化配置。
    - 例如：
      - Guest 想用 Smnpm，它可以通过 SBI_FIRMWARE_FEATURES 来检查宿主机是否支持。

- **KVM**
  - KVM（Kernel-based Virtual Machine）是 Linux 内核内置的 虚拟化解决方案，它能让 Linux 直接变成一个 Type-1 Hypervisor，用于管理虚拟机（Guest OS）。
  - KVM 作用
    - 提供虚拟 CPU（vCPU），让 Guest OS 以为自己运行在真实的硬件上。
    - 管理 Guest OS 的内存、I/O、设备映射。
    - 支持硬件加速（如 RISC-V H 扩展、Intel VT-x、AMD SVM）。

- **vcpu_onereg.c**
  - 文件的作用:vcpu_onereg.c 是 KVM 的一个 vCPU 相关代码文件，用于管理虚拟机的 CPU 寄存器。
  - “one reg” 机制：表示 虚拟 CPU（vCPU） 可以通过 KVM API 访问和修改 单个寄存器。
  - 主要用于：
    - 获取 vCPU 当前状态（例如 pc, sp, hartid）。
    - 修改 vCPU 的寄存器值。
    - 支持不同架构（如 x86, ARM, RISC-V）的虚拟 CPU 操作。

### 3.2 linux->commit
**(09d6775f503b393d0457c7126aa43208e1724004)**

```diff
Misaligned scalar accesses are supported in userspace, but they may perform
 poorly.  Misaligned vector accesses are only supported if the Zicclsm extension
 is supported.
+
+Pointer masking
+---------------
+
+Support for pointer masking in userspace (the Supm extension) is provided via
+the ``PR_SET_TAGGED_ADDR_CTRL`` and ``PR_GET_TAGGED_ADDR_CTRL`` ``prctl()``
+operations. Pointer masking is disabled by default. To enable it, userspace
+must call ``PR_SET_TAGGED_ADDR_CTRL`` with the ``PR_PMLEN`` field set to the
+number of mask/tag bits needed by the application. ``PR_PMLEN`` is interpreted
+as a lower bound; if the kernel is unable to satisfy the request, the
+``PR_SET_TAGGED_ADDR_CTRL`` operation will fail. The actual number of tag bits
+is returned in ``PR_PMLEN`` by the ``PR_GET_TAGGED_ADDR_CTRL`` operation.
```
- 修改了 RISC-V 用户空间 ABI（应用二进制接口）文档，增加了 Pointer Masking 相关的说明：

```diff
+config RISCV_ISA_SUPM
+	bool "Supm extension for userspace pointer masking"
+	depends on 64BIT
+	default y
+	help
+	  Add support for pointer masking in userspace (Supm) when the
+	  underlying hardware extension (Smnpm or Ssnpm) is detected at boot.
```

- 增加了 RISCV_ISA_SUPM 选项，表示是否支持用户空间指针掩码。
- 依赖 64 位（depends on 64BIT），32 位架构不支持该功能。
- 默认启用（default y）。
- 只有在检测到底层硬件支持 Smnpm 或 Ssnpm 扩展时，该功能才会启用。


处理器相关的头文件修改（arch/riscv/include/asm/processor.h）
```diff
+#ifdef CONFIG_RISCV_ISA_SUPM
+/* PR_{SET,GET}_TAGGED_ADDR_CTRL prctl */
+long set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg);
+long get_tagged_addr_ctrl(struct task_struct *task);
+#define SET_TAGGED_ADDR_CTRL(arg)	set_tagged_addr_ctrl(current, arg)
+#define GET_TAGGED_ADDR_CTRL()		get_tagged_addr_ctrl(current)
+#endif
```
这里定义了两个新函数：
set_tagged_addr_ctrl()：用于设置指针掩码模式。
get_tagged_addr_ctrl()：用于查询当前的指针掩码模式。

```diff
+static inline void envcfg_update_bits(struct task_struct *task,
+				      unsigned long mask, unsigned long val)
+{
+	unsigned long envcfg;
+
+	envcfg = (task->thread.envcfg & ~mask) | val;
+	task->thread.envcfg = envcfg;
+	if (task == current)
+		csr_write(CSR_ENVCFG, envcfg);
+}
```

  - envcfg_update_bits() 函数用于更新线程的 ENVCFG（环境配置寄存器）。

- **ENVCFG（Environment Configuration Register**
- ENVCFG 是 RISC-V 的 CSR（Control and Status Register） 之一，控制运行环境的各种特性，
        例如：
  - ENVCFG_PMM（Pointer Masking Mode）：用于配置用户地址标记（tagging）。
  - ENVCFG_PMM_PMLEN_* 代表不同的 PMLEN（Pointer Mask Length）。

- 32 位系统的地址空间太小，无法有效利用指针标记，因此不支持。

```diff
+ if (pmlen <= PMLEN_16 && have_user_pmlen_16)
+ 	pmm = ENVCFG_PMM_PMLEN_16;
```
- pmlen 是用户请求的指针掩码长度。
- PMLEN_16 代表 最大支持 16 位指针掩码。
- have_user_pmlen_16 表示 硬件是否支持 16 位掩码。
- if 语句确保：
  - 用户请求的 pmlen 小于等于 16。
  - 并且 硬件支持 16 位掩码。
- 这样可以尽可能使用 最小满足需求 的 **pmlen，避免性能影响**  。

**prctl(PR_SET_TAGGED_ADDR_CTRL, arg)**
- prctl 是 Linux 的 进程控制系统调用，PR_SET_TAGGED_ADDR_CTRL 让用户进程配置 指针标记功能。PR_PMLEN_MASK 的作用
- arg 传入 prctl(PR_SET_TAGGED_ADDR_CTRL, arg) 时，PR_PMLEN_MASK 用于提取 pmlen：
  - pmlen = FIELD_GET(PR_PMLEN_MASK, arg);
- FIELD_GET() 是 Linux 内核的宏，用于提取位字段：
  - arg & PR_PMLEN_MASK 取出 pmlen 位字段。
  - pmlen 代表用户请求的 指针标记长度。

- **为什么只改变当前进程的CSR_ENVCFG值？**
  - CSR_ENVCFG 是 RISC-V 体系结构下的一个 每核（per-hart）CSR，用于配置进程的执行环境。当进程切换时，CSR 需要相应更新。因此：
  - 如果 task == current，说明更新的正是当前进程，此时需要 立即 将 envcfg 写入 CSR_ENVCFG 使其生效。
  - 其它进程的 CSR_ENVCFG 值不会立即改变，而是等到 任务切换（context switch） 时，由内核调度代码加载该进程的 thread.envcfg 到 CSR_ENVCFG。

**1**. envcfg_update_bits() 仅对当前进程 task == current 时，才会写 CSR_ENVCFG，否则仅修改 task->thread.envcfg，等待任务切换时生效。
**2**. try_to_set_pmm() 通过 csr_set 和 csr_read_clear 检测 PMLEN 是否支持，存入 have_user_pmlen_7/16 供 prctl 使用。
**3**. prctl(PR_SET_TAGGED_ADDR_CTRL) 通过 set_tagged_addr_ctrl() 设置 PMLEN，受 have_user_pmlen_7/16 限制。
**4**. prctl(PR_GET_TAGGED_ADDR_CTRL) 通过 get_tagged_addr_ctrl() 获取当前进程 PMLEN 配置。
**5**. is_compat_thread() 限制 32 位线程调用 prctl(PR_SET_TAGGED_ADDR_CTRL)，因为 PMLEN 仅适用于 64 位进程。

```diff
+# define PR_PMLEN_SHIFT			24
+# define PR_PMLEN_MASK			(0x7fUL << PR_PMLEN_SHIFT)
```
- 新增了 RISC-V 相关的 PMLEN（Pointer Mask Length，指针掩码长度）定义。
  - PR_PMLEN_SHIFT = 24 说明 PMLEN 从 bit 24 开始。
  - PR_PMLEN_MASK = (0x7fUL << PR_PMLEN_SHIFT) 说明 PMLEN 占 7 位，用于存储指针掩码的长度信息。


### 3.3 linux->commit
**(2e1743085887ba3f553c2bb472a75a3ff744b242)**

- **这段代码是 RISC-V 架构在 Linux Kernel 中对 Tagged Address ABI（标记地址 ABI）的支持补丁，目的是让 用户态 能够使用 带标记的指针（Tagged Pointers），并在 内核访问用户地址 时去除这些标记（untagging）。主要修改涉及 内存管理（MMU）、用户访问（uaccess）、进程管理等部分。**








### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

### 1. linux->commit
**()**

